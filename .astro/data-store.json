[["Map",1,2,9,10,40,41,50,177],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.5.5","content-config-digest","301cf414f105531e","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"ignore\",\"output\":\"static\",\"scopedStyleStrategy\":\"attribute\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":true,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":true,\"port\":4321,\"streaming\":true,\"allowedHosts\":[]},\"redirects\":{},\"image\":{\"endpoint\":{\"route\":\"/_image\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[]},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":{\"type\":\"shiki\",\"excludeLangs\":[\"math\"]},\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"github-dark\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[],\"rehypePlugins\":[],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"responsiveImages\":false,\"svg\":{\"mode\":\"sprite\"},\"serializeConfig\":false,\"headingIdCompat\":false,\"preserveScriptOrder\":false},\"legacy\":{\"collections\":false}}","patterns",["Map",11,12,26,27],"observer-pattern",{"id":11,"data":13,"body":21,"filePath":22,"digest":23,"legacyId":24,"deferredRender":25},{"title":14,"description":15,"pubDate":16,"author":17,"tags":18},"Understanding the Observer Pattern","A comprehensive guide to implementing the Observer pattern in modern applications",["Date","2024-01-21T00:00:00.000Z"],"Jane Smith",[19,20],"design patterns","reactive programming","# Understanding the Observer Pattern\n\nThe Observer pattern defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.\n\n## Key Components\n\n1. Subject (Observable)\n2. Observer\n3. Concrete Subject\n4. Concrete Observer\n\n## Implementation Example\n\n```javascript\nclass Observable {\n    constructor() {\n        this.observers = new Set();\n    }\n\n    subscribe(observer) {\n        this.observers.add(observer);\n    }\n\n    unsubscribe(observer) {\n        this.observers.delete(observer);\n    }\n\n    notify(data) {\n        this.observers.forEach(observer => observer.update(data));\n    }\n}\n```\n\n## Real-world Applications\n\n- Event handling systems\n- User interface components\n- Real-time data updates","src/content/patterns/observer-pattern.mdx","49027a06341019c1","observer-pattern.mdx",true,"singleton-pattern",{"id":26,"data":28,"body":36,"filePath":37,"digest":38,"legacyId":39,"deferredRender":25},{"title":29,"description":30,"pubDate":31,"author":32,"tags":33},"The Singleton Pattern in Modern JavaScript","Learn how to implement and use the Singleton pattern effectively in modern JavaScript applications",["Date","2024-01-20T00:00:00.000Z"],"John Doe",[19,34,35],"javascript","architecture","# The Singleton Pattern in Modern JavaScript\n\nThe Singleton pattern is one of the most well-known design patterns in software engineering. It ensures a class has only one instance and provides a global point of access to that instance.\n\n## Implementation in JavaScript\n\nHere's a modern implementation using ES6+ features:\n\n```javascript\nclass Singleton {\n    static #instance;\n    \n    constructor() {\n        if (Singleton.#instance) {\n            return Singleton.#instance;\n        }\n        Singleton.#instance = this;\n    }\n    \n    static getInstance() {\n        return new Singleton();\n    }\n}\n```\n\n## Use Cases\n\n1. Configuration Management\n2. Database Connections\n3. Logging Services\n\n## Best Practices\n\n- Use private fields for better encapsulation\n- Consider using dependency injection instead\n- Test for thread safety in concurrent environments","src/content/patterns/singleton-pattern.mdx","b2c6fe1526ec4380","singleton-pattern.mdx","react-patterns",["Map",42,43,57,58,67,68,77,78,87,88,97,98,107,108,117,118,127,128,137,138,147,148,157,158,167,168],"centralized-logging-and-monitoring",{"id":42,"data":44,"body":53,"filePath":54,"digest":55,"legacyId":56,"deferredRender":25},{"title":45,"description":46,"pubDate":47,"author":48,"tags":49},"Centralized Logging & Monitoring","Lorem ipsum dolor sit amet, consectetur adipiscing elit.",["Date","2024-01-23T00:00:00.000Z"],"Sarah Wilson",[50,51,52],"principles","clean code","maintainability","# Centralized Logging & Monitoring (Sentry, LogRocket, Datadog)","src/content/react-patterns/centralized-logging-and-monitoring.mdx","19b8b8d3aad5827c","centralized-logging-and-monitoring.mdx","container-presentational",{"id":57,"data":59,"body":63,"filePath":64,"digest":65,"legacyId":66,"deferredRender":25},{"title":60,"description":46,"pubDate":61,"author":48,"tags":62},"Container-Presentational Pattern",["Date","2024-01-23T00:00:00.000Z"],[50,51,52],"Container-Presentational Pattern হলো Separation of Concerns (SoC) প্রিন্সিপাল\nমেনে কম্পোনেন্ট ডিজাইন করার একটি পদ্ধতি। এই ক্ষেত্রে বা এই প্যাটার্নের ক্ষেত্রে\nআমাদের UI (Presentational) Component এবং Logic (Container) Component আলাদা আলাদা\nকরি।  \nযেমন ধরি Parent Component এর কাছে সকল প্রকার logic, Data fetching এসব করা হল এবং\nChild Component সেগুলা শুধু রেন্ডার করা কাজ করবে । এক্ষেত্রে সুবিধা হবে Child\nComponent গুলো চাইলে আমরা অন্যান্য নানা জায়গায় ব্যবহার করতে পারব , অর্থাৎ কোডের\nরি-ইউজিবিলিটি বাড়বে ও আমাদের কম কোড লেখা লাগবে। এক্ষেত্রে একটা জিনিস মাথায় রাখা\nলাগবে যে আমাদের Child Component গুলো যত সম্ভব Dumb Component বানাতে হবে, এখানে\nDumb Component বলতে কি বুঝানো হয়েছে? Dumb Component বলতে এসব Component বিশেষ\nলজিক ধারণ করবে না ফলে এটাকে প্রপস পাঠিয়ে আমরা নানা জায়গায় ব্যবহার করতে পারব\n\n\u003Ctable>\n  \u003Cthead>\n    \u003Ctr>\n      \u003Cth>বিষয়\u003C/th>\n      \u003Cth>Container Component\u003C/th>\n      \u003Cth>Presentational Component\u003C/th>\n    \u003C/tr>\n  \u003C/thead>\n  \u003Ctbody>\n    \u003Ctr>\n      \u003Ctd>\n        \u003Cstrong>কাজ\u003C/strong>\n      \u003C/td>\n      \u003Ctd>Data fetching, state management, business logic হ্যান্ডেল করা\u003C/td>\n      \u003Ctd>শুধুমাত্র UI এবং props অনুযায়ী রেন্ডারিং করা\u003C/td>\n    \u003C/tr>\n    \u003Ctr>\n      \u003Ctd>\n        \u003Cstrong>Dependency\u003C/strong>\n      \u003C/td>\n      \u003Ctd>External API, Redux, Context, Hooks ব্যবহার করতে পারে\u003C/td>\n      \u003Ctd>শুধুমাত্র UI রেন্ডার করে, external dependency কম থাকে\u003C/td>\n    \u003C/tr>\n    \u003Ctr>\n      \u003Ctd>\n        \u003Cstrong>State Management\u003C/strong>\n      \u003C/td>\n      \u003Ctd>Stateful হতে পারে (useState, useEffect ব্যবহার করতে পারে)\u003C/td>\n      \u003Ctd>Stateless হয়, শুধুমাত্র props-এর ওপর নির্ভর করে\u003C/td>\n    \u003C/tr>\n    \u003Ctr>\n      \u003Ctd>\n        \u003Cstrong>Responsibility\u003C/strong>\n      \u003C/td>\n      \u003Ctd>UI Component-এ props পাঠানো ও event handler সেট করা\u003C/td>\n      \u003Ctd>UI প্রদর্শন করা ও props থেকে ডাটা দেখানো\u003C/td>\n    \u003C/tr>\n    \u003Ctr>\n      \u003Ctd>\n        \u003Cstrong>Code Reusability\u003C/strong>\n      \u003C/td>\n      \u003Ctd>\n        একটি container কম্পোনেন্ট বিভিন্ন UI কম্পোনেন্টের জন্য data handle করতে\n        পারে\n      \u003C/td>\n      \u003Ctd>একই UI বিভিন্ন জায়গায় পুনরায় ব্যবহার করা যায়\u003C/td>\n    \u003C/tr>\n  \u003C/tbody>\n\u003C/table>\n\n### এখন আমরা সাধারণভাবে ডিজাইন করে দেখি ।\n\n\u003Cspan className=\"text-sm\"> vue.js এর উদাহরণ নিচের দিকে থাকবে \u003C/span>\n\nউদাহরণঃ\n\n```tsx\nimport { useEffect, useState } from \"react\";\n\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\nconst UserList = () => {\n  const [users, setUsers] = useState\u003CUser[]>([]);\n\n  useEffect(() => {\n    fetch(\"https://jsonplaceholder.typicode.com/users\")\n      .then((res) => res.json())\n      .then((data) => setUsers(data))\n      .catch((err) => console.error(\"Error fetching users:\", err));\n  }, []);\n\n  return (\n    \u003Cdiv className=\"rounded-lg bg-gray-100 p-4\">\n      \u003Ch2 className=\"mb-2 text-lg font-bold\">User List\u003C/h2>\n      \u003Cul>\n        {users.map((user) => (\n          \u003Cli key={user.id} className=\"border-b p-2\">\n            \u003Cstrong>{user.name}\u003C/strong> - {user.email}\n          \u003C/li>\n        ))}\n      \u003C/ul>\n    \u003C/div>\n  );\n};\n\nexport default UserList;\n```\n\nএখানে আমরা সহজ একটা উদাহরণ নিলাম যেখানে, একই Component এর মধ্যেই Data Fetcing ও\nপাশাপাশি আবার সেটা UI তে দেখানোও হচ্ছে । এখানে একটা সমস্যা আছে, সেটা হল যদি\nআমাদের এই API এর নিয়ে কোন কাজ করতে হয় কখনও তখন সেটা আমাদের এই UI এর দিকটাও দেখতে\nহছে , যেখানে একটা লম্বা কোড বেস হবে সেখানে । যা মেন্টেইন করতে কষ্ট হতে পারে।\nআবার এখানে যদি আরও এমন থাকত তখন সিনারিওটা কেমন হতে পারত চিন্তা করা যায় ?\n\n### এখন আমরা এটাকে সহজ ভাবে করব, Container-Presentational Pattern অনুসারে করলে এটা কেমন হত সেটা দেখি এখনঃ\n\n১ . Container Component (UserListContainer.tsx)\n\n```tsx\nimport { useEffect, useState } from \"react\";\nimport UserList from \"./UserList\";\n\nconst UserListContainer = () => {\n  const [users, setUsers] = useState([]);\n\n  useEffect(() => {\n    fetch(\"https://jsonplaceholder.typicode.com/users\")\n      .then((res) => res.json())\n      .then((data) => setUsers(data))\n      .catch((err) => console.error(\"Error fetching users:\", err));\n  }, []);\n\n  return \u003CUserList users={users} />;\n};\n\nexport default UserListContainer;\n```\n\n২ . Presentational Component (UserList.tsx)\n\n```tsx\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\nconst UserList = ({ users }: { users: User[] }) => {\n  return (\n    \u003Cdiv className=\"rounded-lg bg-gray-100 p-4\">\n      \u003Ch2 className=\"mb-2 text-lg font-bold\">User List\u003C/h2>\n      \u003Cul>\n        {users.map((user) => (\n          \u003Cli key={user.id} className=\"border-b p-2\">\n            \u003Cstrong>{user.name}\u003C/strong> - {user.email}\n          \u003C/li>\n        ))}\n      \u003C/ul>\n    \u003C/div>\n  );\n};\n\nexport default UserList;\n```\n\n### সুবিধা কি ?\n\nএখানে আমরা কি এমন এক্সট্রা সুবিধা পাচ্ছি সেটা বিবেচনা করি ;\n\n- Code Maintainability : Logic এবং UI আলাদা থাকায় কোড বুঝতে ও মেইনটেইন করতে সহজ\n  হয়। যদি এখানে আরও অনেক কোড থাকত তখন সেটা মেইন্টেইন করা ও কোড রিড করা কষ্টদায়ক\n  হত ।\n- Reusability : UserList কম্পোনেন্টকে অন্য জায়গায়ও ব্যবহার করা যাবে, এটাকে\n  চাইলেই আমরা নানা ভাবে নানা জায়গায় এই Data কে Props হিসেবে দিয়েই ব্যবহার করতে\n  পারব ।\n- Scalability : প্রজেক্ট বড় হলেও সমস্যা হবে না, কারণ কম্পোনেন্টগুলো স্পষ্টভাবে\n  আলাদা থাকে।\n- Testing সহজ হয় : Presentational Component গুলো সহজে টেস্ট করা যায় কারণ তারা\n  শুধুমাত্র UI রেন্ডার করে। যেমন আমরা চাইলে data fetching টাও অন্য `file` এ করে\n  সেটা এখানে ব্যবহার করতে পারতাম, এক্ষেত্রে সেই ফাইলে সহজেই unit test করা যেত ।\n\nসুতরাং, এসকল সুবিধার জন্য আমরা মূলত এই Pattern ব্যবহার করতে পারি । এক্ষেত্রে এই\nপ্যাটার্ন Separation of concerns priciple ফলো করে ও সেটাকে মেনে চলে । অর্থাৎ\nSeparation of concerns ও ঠিক এই বিষয়ে বলে আর আমরা এই ডিজাইন প্যাটার্ন মেনে চললে\nসেটাই তখন Separation of concerns এর নিয়ম সন্তুষ্ট করে ।\n\n## Single Responsibility Principle (SRP)\n\nএখন আমরা এই ধরনের আরেকটা ইম্পোর্টেন্ট প্রিসিসিপাল বা কনভেনশন সম্পর্কে জানব আর\nসেটা হল Single Responsibility Principle । এর নাম দিয়েই এটা অনেকটা বুঝা যায় ,\nSingle Responsibility Principle এর মানে হল কোন নির্দিষ্ট একটা Component টি কোণ\nনির্দিষ্ট একটা কাজ করবে অর্থাৎ Single Responsibility ধারণ করবে তা নিয়েই কাজ করবে\n।\n\nSingle Responsibility Principle ও Separation of concerns Principle অনেকটা\nসিমিলার যদিও বেশ পার্থক্য আছে ,\n\nযেমন,\n\n- Separation of concerns Principle অন্যযায়ী UI and business logic, state আলাদা\n  হবে এখানে parent Component চাইলে একাধিক data fetching বা business logic রাখতে\n  পারব\n- Single Responsibility Principle অন্যযায়ী তা হবে না , কোন নির্দিষ্ট `File` সে\n  নির্দিষ্ট একটা কাজই করবে বা উদাহরণ হিসেবে বলতে পারি যেমন সে একটা বিষয় Data\n  Fetch করে সেটা UI তে রেন্ডার করবে ।\n\n  #### SRP এর উদাহরণ\n\n  আমরা আমাদের আগের উপরের আগের কোড এর উদাহরণ দেখি । সেখানে আমরা রি-ফ্যাক্টর করে আলাদা কম্পোনেন্ট করছিলাম কিন্তু আমরা fetch এর লগিক আলদা করিনি, যদি আমাদের সেম ডাটা কোথাও আবার fetch করতে হয় তখন সেটা আবার আমাদের লিখতে হবে ।\n  আবার এখানে, Container-Presentational Pattern এর প্রিসিপাল স্যাটিস্ফাই করলেও Single Responsibility Principle সেটিস্ফাই করতে পারেনি, এর কারণ ?\n  মূলত এখানে আমাদের Container Component কি কাজ করছে ?\n\n  - Data Fetch করছে ও সেটার লজিক হ্যান্ডেল করছে ।\n  - সেটা child components এর কাছে পাঠিয়েছিয়ে ।\n\n  অর্থাৎ এখানে কিন্তু এর ২টা কাজ করতে হচ্ছে । এক্ষেত্রে যদি আমরা Single Responsibility Principle কেও সন্তুষ্ট করতে চাই তাহলে সে হিসেবে আমাদের প্রতি components, hook এর নির্দিষ্ট একটা কাজই করতে হবে ।\n  উদাহরণঃ\n\ncontainer / parent components\n\n```tsx\nimport useUsers from \"../hooks/useUsers\";\nimport UserList from \"./UserList\";\n\nconst UserListContainer = () => {\n  const { users, error, loading } = useUsers();\n\n  if (loading) return \u003Cp>Loading users...\u003C/p>;\n  if (error) return \u003Cp className=\"text-red-500\">{error}\u003C/p>;\n\n  return \u003CUserList users={users} />;\n};\n\nexport default UserListContainer;\n```\n\ncustom hook for data fetching about user\n\n```tsx\nimport { useEffect, useState } from \"react\";\n\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\nconst useUsers = () => {\n  const [users, setUsers] = useState\u003CUser[]>([]);\n  const [error, setError] = useState\u003Cstring | null>(null);\n  const [loading, setLoading] = useState\u003Cboolean>(true);\n\n  useEffect(() => {\n    const fetchUsers = async () => {\n      try {\n        const response = await fetch(\n          \"https://jsonplaceholder.typicode.com/users\"\n        );\n        if (!response.ok) throw new Error(\"Failed to fetch users\");\n        const data = await response.json();\n        setUsers(data);\n      } catch (err) {\n        setError((err as Error).message);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchUsers();\n  }, []);\n\n  return { users, error, loading };\n};\n\nexport default useUsers;\n```\n\n### বিশ্লেষণঃ\n\n- data fetching logic আমরা useUsers নামের একটা কাস্টম Hooks এর মধ্যে নিয়ে গেলাম ।\n- container থেকেই এর loading, error এবং data দেখানোর জন্য UserList component এর কাছে পাঠিয়েছিয়ে । (error,data, loading এগুলা একটা `group of work ` বা রিলেটেড single কাজই )\n- UserList এর কার্ড এর কাজ হল যদি data পাঠানো হয় তাহলে সেটা UI তে দেখানো । এক্ষেত্রে এটাকে চাইলে অন্য সব জায়গায়ও ভিন্ন ভিন্ন ডাটা দিয়ে ব্যবহার করতে পারব ।\n\n## vue.js এর সাথে Container-Presentational Pattern এর উদাহরণ\n\n##### উদাহরণ হিসেবে আমরা সাধারণ একটা কোম্পানেন্ট বানিয়ে নেই ।\n\n```vue\n\u003Cscript setup>\nimport { ref, onMounted } from \"vue\";\n\nconst users = ref([]);\n\nonMounted(async () => {\n  try {\n    const response = await fetch(\"https://jsonplaceholder.typicode.com/users\");\n    users.value = await response.json();\n  } catch (error) {\n    console.error(\"Error fetching users:\", error);\n  }\n});\n\u003C/script>\n\n\u003Ctemplate>\n  \u003Cdiv class=\"rounded-lg bg-gray-100 p-4\">\n    \u003Ch2 class=\"mb-2 text-lg font-bold\">User List\u003C/h2>\n    \u003Cul>\n      \u003Cli v-for=\"user in users\" :key=\"user.id\" class=\"border-b p-2\">\n        \u003Cstrong>{{ user.name }}\u003C/strong> - {{ user.email }}\n      \u003C/li>\n    \u003C/ul>\n  \u003C/div>\n\u003C/template>\n```\n\n##### Container-Presentational Pattern ফলো করে এইবার আমরা করি ।\n\n1: Container Component (UserListContainer.vue)\n\n```vue\n\u003C!-- src/components/UserListContainer.vue -->\n\u003Cscript setup>\nimport { ref, onMounted } from \"vue\";\nimport UserList from \"./UserList.vue\";\n\nconst users = ref([]);\n\nonMounted(async () => {\n  try {\n    const response = await fetch(\"https://jsonplaceholder.typicode.com/users\");\n    users.value = await response.json();\n  } catch (error) {\n    console.error(\"Error fetching users:\", error);\n  }\n});\n\u003C/script>\n\n\u003Ctemplate>\n  \u003CUserList :users=\"users\" />\n\u003C/template>\n```\n\n2: Presentational Component (UserList.vue)\n\n```vue\n\u003C!-- src/components/UserList.vue -->\n\u003Cscript setup>\ndefineProps({\n  users: Array,\n});\n\u003C/script>\n\n\u003Ctemplate>\n  \u003Cdiv class=\"rounded-lg bg-gray-100 p-4\">\n    \u003Ch2 class=\"mb-2 text-lg font-bold\">User List\u003C/h2>\n    \u003Cul>\n      \u003Cli v-for=\"user in users\" :key=\"user.id\" class=\"border-b p-2\">\n        \u003Cstrong>{{ user.name }}\u003C/strong> - {{ user.email }}\n      \u003C/li>\n    \u003C/ul>\n  \u003C/div>\n\u003C/template>\n```","src/content/react-patterns/container-presentational.mdx","a0749b130434eb1c","container-presentational.mdx","control-props-pattern",{"id":67,"data":69,"body":73,"filePath":74,"digest":75,"legacyId":76,"deferredRender":25},{"title":70,"description":46,"pubDate":71,"author":48,"tags":72},"Control Props Pattern",["Date","2024-01-23T00:00:00.000Z"],[50,51,52],"# Control Props Pattern (Allowing external control over components)","src/content/react-patterns/control-props-pattern.mdx","cd6d4059e366ac66","control-props-pattern.mdx","custom-hooks-for-abstraction",{"id":77,"data":79,"body":83,"filePath":84,"digest":85,"legacyId":86,"deferredRender":25},{"title":80,"description":46,"pubDate":81,"author":48,"tags":82},"Custom Hooks for Abstraction",["Date","2024-01-23T00:00:00.000Z"],[50,51,52],"# Custom Hooks for Abstraction (Encapsulating reusable logic)","src/content/react-patterns/custom-hooks-for-abstraction.mdx","feaf8b863dd7465c","custom-hooks-for-abstraction.mdx","effect-synchronization",{"id":87,"data":89,"body":93,"filePath":94,"digest":95,"legacyId":96,"deferredRender":25},{"title":90,"description":46,"pubDate":91,"author":48,"tags":92},"Effect Synchronization",["Date","2024-01-23T00:00:00.000Z"],[50,51,52],"# Effect Synchronization (useEffect dependency patterns)","src/content/react-patterns/effect-synchronization.mdx","c0fcd387ab6e19dd","effect-synchronization.mdx","compound-components-pattern",{"id":97,"data":99,"body":103,"filePath":104,"digest":105,"legacyId":106,"deferredRender":25},{"title":100,"description":46,"pubDate":101,"author":48,"tags":102},"Compound Components Pattern",["Date","2024-01-23T00:00:00.000Z"],[50,51,52],"# Compound Components Pattern (Encapsulating related behaviors)","src/content/react-patterns/compound-components-pattern.mdx","a49ca56d0ac7359e","compound-components-pattern.mdx","error-boundaries",{"id":107,"data":109,"body":113,"filePath":114,"digest":115,"legacyId":116,"deferredRender":25},{"title":110,"description":46,"pubDate":111,"author":48,"tags":112},"Error Boundaries",["Date","2024-01-23T00:00:00.000Z"],[50,51,52],"# Error Boundaries for Component Crashes","src/content/react-patterns/error-boundaries.mdx","ecd64b952b6b0a56","error-boundaries.mdx","factory-hook-pattern",{"id":117,"data":119,"body":123,"filePath":124,"digest":125,"legacyId":126,"deferredRender":25},{"title":120,"description":46,"pubDate":121,"author":48,"tags":122},"Factory Hook Pattern",["Date","2024-01-23T00:00:00.000Z"],[50,51,52],"# Factory Hook Pattern (Generating hooks dynamically)","src/content/react-patterns/factory-hook-pattern.mdx","b78a8d37b633dc4f","factory-hook-pattern.mdx","function-children-pattern",{"id":127,"data":129,"body":133,"filePath":134,"digest":135,"legacyId":136,"deferredRender":25},{"title":130,"description":46,"pubDate":131,"author":48,"tags":132},"Function Children Pattern",["Date","2024-01-23T00:00:00.000Z"],[50,51,52],"# Function Children Pattern (Hooks inside JSX)\n\nFCP মুলত `Render Props` এর আপডেট ভার্সন । যেখানে `render props ` ব্যবহার করা যায় সেখানেই `Function Children Pattern` ব্যবহার করা যায় ।\n\n## 🔹 Function Children Pattern কি?\n\nFunction Children Pattern হলো একটি React pattern যেখানে একটি component তার children হিসেবে একটি function গ্রহণ করে এবং সেই function কে render করার সময় call করে। এই pattern সাধারণত তখন ব্যবহৃত হয় যখন parent component তার child component কে কিছু state বা props পাঠাতে চায় এবং child component সেটি ব্যবহার করে dynamic ভাবে content render করে।\n\n### গঠন (বেসিক উদাহরণ )\n\n```tsx\ntype RenderProps = {\n  count: number;\n  increment: () => void;\n};\n\nconst Counter = ({\n  children,\n}: {\n  children: (props: RenderProps) => React.ReactNode;\n}) => {\n  const [count, setCount] = React.useState(0);\n\n  const increment = () => setCount((prev) => prev + 1);\n\n  return \u003C>{children({ count, increment })}\u003C/>;\n};\n\nconst App = () => {\n  return (\n    \u003CCounter>\n      {({ count, increment }) => (\n        \u003Cdiv>\n          \u003Cp>Count: {count}\u003C/p>\n          \u003Cbutton onClick={increment}>Increment\u003C/button>\n        \u003C/div>\n      )}\n    \u003C/Counter>\n  );\n};\n\nexport default App;\n```\n\n### render props এর থেকে কি বেশি সুবিধা পাই ?\n\n- render props এর ক্ষেত্রে নেস্টেড বা অনেক JSX হলে তা জটিল হয় এক্ষেত্রে function children এর ক্ষেত্রে তা সহজ হয় ।\n- তুলনামূলক কম কোড ও সহজ হয় ।\n- কোন এক্সট্রা props এর type লেখা লাগে না (TypeScript এর ক্ষেত্রে)","src/content/react-patterns/function-children-pattern.mdx","b72d869999b8b22e","function-children-pattern.mdx","graceful-degradation-fallback-ui",{"id":137,"data":139,"body":143,"filePath":144,"digest":145,"legacyId":146,"deferredRender":25},{"title":140,"description":46,"pubDate":141,"author":48,"tags":142},"Graceful Degradation & Fallback UI",["Date","2024-01-23T00:00:00.000Z"],[50,51,52],"# Graceful Degradation & Fallback UI (Showing proper messages)","src/content/react-patterns/graceful-degradation-fallback-uI.mdx","0c1bc313b82d5d93","graceful-degradation-fallback-uI.mdx","higher-order-components",{"id":147,"data":149,"body":153,"filePath":154,"digest":155,"legacyId":156,"deferredRender":25},{"title":150,"description":46,"pubDate":151,"author":48,"tags":152},"Higher Order Components",["Date","2024-01-23T00:00:00.000Z"],[50,51,52],"# Higher Order Components (HOC)\n\nHOC হল একটি ফাংশন যা একটি Components নেয় এবং একটি নতুন Enhanced Components রিটার্ন করে।\n\n### HOC ব্যবহারের সুবিধা ?\n\n- Code Reusability: রি-ইউজিবল লজিক আলাদা রাখা যায়।\n- Separation of Concerns: লজিক ও UI আলাদা করা যায়।\n- Props Manipulation: ইনপুট কম্পোনেন্টকে নতুন props যোগ করা যায়।\n- Authentication Handling: ব্যবহারের পার্মিশন চেক করা যায়।\n- Conditional Rendering: নির্দিষ্ট শর্ত অনুযায়ী UI চেঞ্জ করা যায়। বা বলতে পারি if else দিয়ে বা কনডিশনালি চেক করে আমরা চাইলে রি-ইউজ কিছু দেখাতে পারি ।\n\n### HOC এর মূল ধারনা\n\n- এটি একটি কম্পোনেন্টকে ইনপুট হিসেবে নেয়।\n- প্রয়োজনীয় লজিক অ্যাপ্লাই করে।\n- একটি নতুন উন্নত কম্পোনেন্ট রিটার্ন করে।\n\nHOC এর ক্ষেত্রে একটা কনভেনশন হল এর শুরু হবে with দিয়ে, যেমন আমরা hooks লিখে শুরুতে use দিয়ে , এভাবেই HOC এর ক্ষেত্রে with দেয়া একটা কনভেনশন হিসেবে ধরা হয় । যেমনঃ withUserData  \n যদিও React এর ক্ষেত্রে Hooks আসার পর থেকে HOC তেমন ব্যবহার হয় না কারণ আমরা HOC এর কাজ hooks ব্যবহার করে আরও সহজেই করতে পারি ।\n\n##### HOC উদাহরণ\n\nwith-user-data.tsx\n\n```tsx\nimport React, { useEffect, useState } from \"react\";\n\ntype User = {\n  id: number;\n  name: string;\n  email: string;\n  phone: string;\n};\n\n// HOC to fetch user data\nconst withUserData = \u003CP extends object>(\n  WrappedComponent: React.ComponentType\u003CP & { users: User[] }>\n) => {\n  return (props: P) => {\n    const [users, setUsers] = useState\u003CUser[]>([]);\n    const [loading, setLoading] = useState\u003Cboolean>(true);\n    const [error, setError] = useState\u003Cstring | null>(null);\n\n    useEffect(() => {\n      const fetchUsers = async () => {\n        try {\n          const response = await fetch(\n            \"https://jsonplaceholder.typicode.com/users\"\n          );\n          if (!response.ok) {\n            throw new Error(\"Failed to fetch users\");\n          }\n          const data = await response.json();\n          setUsers(data);\n        } catch (err) {\n          setError((err as Error).message);\n        } finally {\n          setLoading(false);\n        }\n      };\n\n      fetchUsers();\n    }, []);\n\n    if (loading) return \u003Cp>Loading users...\u003C/p>;\n    if (error) return \u003Cp>Error: {error}\u003C/p>;\n\n    return \u003CWrappedComponent {...props} users={users} />;\n  };\n};\n```\n\nUserContainer.tsx\n\n```tsx\nconst UserList = ({ users }: { users: User[] }) => {\n  return (\n    \u003Cdiv>\n      \u003Ch2>User List\u003C/h2>\n      \u003Cul>\n        {users.map((user) => (\n          \u003Cli key={user.id}>\n            \u003Cstrong>{user.name}\u003C/strong> - {user.email} - {user.phone}\n          \u003C/li>\n        ))}\n      \u003C/ul>\n    \u003C/div>\n  );\n};\n\nconst UserListWithData = withUserData(UserList);\n```\n\nApp.tsx\n\n```tsx\nexport default function App() {\n  return (\n    \u003Cdiv>\n      \u003Ch1>React HOC Example - withUserData\u003C/h1>\n      \u003CUserListWithData />\n    \u003C/div>\n  );\n}\n```","src/content/react-patterns/higher-order-components.mdx","a06f0184bd469706","higher-order-components.mdx","provider-pattern",{"id":157,"data":159,"body":163,"filePath":164,"digest":165,"legacyId":166,"deferredRender":25},{"title":160,"description":46,"pubDate":161,"author":48,"tags":162},"Provider Pattern",["Date","2024-01-23T00:00:00.000Z"],[50,51,52],"# Provider Pattern (Dependency injection-like state management)","src/content/react-patterns/provider-pattern.mdx","3aedfd1305908a79","provider-pattern.mdx","render-props-pattern",{"id":167,"data":169,"body":173,"filePath":174,"digest":175,"legacyId":176,"deferredRender":25},{"title":170,"description":46,"pubDate":171,"author":48,"tags":172},"Render Props Pattern",["Date","2024-01-23T00:00:00.000Z"],[50,51,52],"# Render Props Pattern (Sharing logic between components)\n\nRPP এর doc অফিশিয়ালি আছে [React Doc - Legacy](https://legacy.reactjs.org/docs/render-props.html) তে ।\nRPP মূলত Higher Order Components (HOC) এর এক্সটেন্ডেড ভার্সন, HOC এর থেকে বেটার সুবিধা পাওয়া যায় বলে এটা বহুল প্রচলিত । যদিও Hooks আসার পর HOC এর তেমন আর ব্যবহার হয় না কিন্তু RPP এখনও অনেক ক্ষেত্রে প্রয়োজন পরে ।\n\nজনপ্রিয় Reactjs লাইব্রারি এর মধ্যে একটা React Router যা RPP ব্যবহার করে কাজ করে । (যদিও বর্তমান সময়ে পরিবর্তন হতে পারে) ।\n\nউদাহরণঃ\n\n```tsx\nimport { BrowserRouter as Router, Route } from \"react-router-dom\";\n\nconst App = () => (\n  \u003CRouter>\n    \u003CRoute path=\"/user\" render={() => \u003Ch1>User Page\u003C/h1>} />\n  \u003C/Router>\n);\n```\n\nআবার, `react-hook-form` এর `Controller` component টাও কিন্তু Render Props দিয়েই করা, , বিস্তারিত [Official Doc](https://react-hook-form.com/docs/usecontroller/controller)\n\nউদাহরণঃ\n\n```tsx\n\u003CController\n  control={control}\n  name=\"ReactDatepicker\"\n  render={({ field: { onChange, onBlur, value, ref } }) => (\n    \u003CReactDatePicker onChange={onChange} onBlur={onBlur} selected={value} />\n  )}\n/>\n```\n\n## Render Props Pattern কিভাবে কাজ করে ?\n\nRender Prop এমন একটি টেকনিক বোঝায় যা কোনও component প্রপ হিসাবে কোনও ফাংশন পাস করা , সেই ফাংশন দ্বারা পাস করা component কনডিশনালি বা ফাংশনালিটি অন্যযায়ী রেন্ডার করতে দেয়।\nRender Props শব্দটি render ও props এই ২টা শব্দ থেকে এসেছে । এখানে render নামের একটা props এর মধ্যে আমরা JSX পাস করেতে পারি আবার সেখানেই wrapper থেকে আমাদের লজিক লেখা ডাটা পেতেও পারি ।\n\nযেমনঃ\n\n```jsx\n\u003CTitle render={() => \u003Ch1> Hello, I am Yeasin !\u003C/h1>} />\n```\n\nএখানে আমরা `Title` Component টা ইনভোক করা হল render নামে props দিয়ে । সাধারণত আমরা এক্ষেত্রে `render` নামের একটা `props` পাঠিয়ে `JSX` পাস করি । এ থেকেই নাম হয়েছে `render props`\n\nতো, এটা কাজ কিভাবে করল ?\n\n```tsx\nconst Title = (props) => props.render();\n```\n\nTitle নামের এই Component টার দিকে একটু লক্ষ্য করি, এখানে props.render() এর এখানে কি হচ্ছে?\nমূলত আমাদের পাস করা render নামের Props টীর টাইপ JSX Element তাই JSX একটা ফাংশন যা `react` আমাদের জন্য `invocoke` করে দেয় তবে এক্ষেত্রে আমরা ম্প্যানুয়ালী করছি ।\n\nএটাকে আরেকটু এক্সটেন্ড করি বিসারিত বুঝার জন্য ।\n\n```tsx\nconst Title = ({\n  render,\n  bgColor = \"bg-gray-100\",\n}: {\n  render: () => React.ReactNode;\n  bgColor?: string;\n}) => {\n  return (\n    \u003Cdiv className={`p-4 rounded-lg shadow-md ${bgColor}`}>\n      \u003Ch1 className=\"text-2xl font-bold text-blue-600\">{render()}\u003C/h1>\n      \u003Cp className=\"text-sm text-gray-500 mt-2\">\n        This is a dynamically styled title component.\n      \u003C/p>\n    \u003C/div>\n  );\n};\n```\n\nএখন এটা ব্যবহার করতে চাইলে আমরা এভাবে করতে পারি ,\n\n```tsx\n\u003CTitle\n  bgColor=\"bg-yellow-100\"\n  render={() => \u003Cspan>Dynamic Render Props!\u003C/span>}\n/>\n```\n\nএখানে যদিও বেসিক এক্সাম্পল দেখানো হচ্ছে বুঝার সুবিধার্থে, তবে চাইলে এটাকে আমরা আরও এক্সটেন্ড করে নিতে পারব । render এর মধ্যে যেকোন কিছু দিয়ে সেই ডাইনামিক কিছু করতে পারব আবার props.render(); করার ক্ষেত্রে `props.render({name: \"Yeasin\"});` এমন নানা Dynamic data চাইলে পাঠাতে পারব যা প্রয়োজনভেদে আলাদা আলাদা component টে ব্যবহার হলেও ভিন্ন ভিন্ন ভাবে দেখাতে পারবে ।\n\n#### render কিভাবে UI তে দেখাচ্ছে,\n\nযেহেতু render নামের props টি JSX Element পাঠাবে তাই সেটা সরাসরি invoke করা যায় । কিন্তু কিভাবে ?\n\n```tsx\n\u003CTitle />;\nTitle();\n```\n\nএই ২টা মূলত একই, প্রতিটি Component আসলে Function যার কারণে আমরা এর নাম `ফংশনাল কম্পোনেন্ট` বলে থাকি .\n\n### বাস্তব উদাহরণঃ\n\nএক্ষেত্রে আমরা আমাদের সেই HOC তে দেখানো আগের component এর উদাহরণ কোডই আবারও Render props Pattern দিয়ে করে দেখাব ।\n\nফোল্ডার স্টাকচারঃ\n\n```md\n/src\n├── components\n│ ├── FetchUsers.tsx \u003C-- Render Props Component\n│ ├── UserList.tsx \u003C-- Uses FetchUsers\n│ └── UserCard.tsx \u003C-- (Optional) Single user item component\n├── App.tsx\n├── main.tsx\n```\n\n#### ১। FetchUsers.tsx (Render Props Component)\n\n```tsx\nimport { useEffect, useState } from \"react\";\n\nexport interface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\ninterface FetchUsersProps {\n  render: (users: User[]) => JSX.Element;\n}\n\nconst FetchUsers = ({ render }: FetchUsersProps) => {\n  const [users, setUsers] = useState\u003CUser[]>([]);\n\n  useEffect(() => {\n    fetch(\"https://jsonplaceholder.typicode.com/users\")\n      .then((res) => res.json())\n      .then((data) => setUsers(data))\n      .catch((err) => console.error(\"Error fetching users:\", err));\n  }, []);\n\n  return render(users);\n  // Or with any style:  return \u003Cdiv> styling and then: render(users);  \u003C/div>\n};\n\nexport default FetchUsers;\n```\n\n#### ২। UserCard.tsx (Optional: Single User Component)\n\n```tsx\nimport { User } from \"./FetchUsers\";\n\nconst UserCard = ({ user }: { user: User }) => {\n  return (\n    \u003Cli key={user.id} className=\"border-b p-2\">\n      \u003Cstrong>{user.name}\u003C/strong> - {user.email}\n    \u003C/li>\n  );\n};\n\nexport default UserCard;\n```\n\n#### ৩। UserList.tsx (Uses FetchUsers with Render Props)\n\n```tsx\nimport FetchUsers from \"./FetchUsers\";\nimport UserCard from \"./UserCard\";\n\nconst UserList = () => {\n  return (\n    \u003CFetchUsers\n      render={(users) => (\n        \u003Cdiv className=\"rounded-lg bg-gray-100 p-4\">\n          \u003Ch2 className=\"mb-2 text-lg font-bold\">User List\u003C/h2>\n          \u003Cul>\n            {users.map((user) => (\n              \u003CUserCard key={user.id} user={user} />\n            ))}\n          \u003C/ul>\n        \u003C/div>\n      )}\n    />\n  );\n};\n\nexport default UserList;\n```\n\n#### ৪। App.tsx\n\n```tsx\nimport UserList from \"./components/UserList\";\n\nconst App = () => {\n  return (\n    \u003Cdiv className=\"container mx-auto p-4\">\n      \u003CUserList />\n    \u003C/div>\n  );\n};\n\nexport default App;\n```","src/content/react-patterns/render-props-pattern.mdx","3e7d7a8f89f18b34","render-props-pattern.mdx",["Map",178,179,189,190],"dry-principle",{"id":178,"data":180,"body":185,"filePath":186,"digest":187,"legacyId":188,"deferredRender":25},{"title":181,"description":182,"pubDate":183,"author":48,"tags":184},"DRY: Don't Repeat Yourself","Understanding and applying the DRY principle in software development",["Date","2024-01-23T00:00:00.000Z"],[50,51,52],"# DRY: Don't Repeat Yourself\n\nThe DRY principle states that \"Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.\"\n\n## Why DRY Matters\n\n1. Reduces maintenance overhead\n2. Minimizes bugs\n3. Improves code readability\n4. Makes refactoring easier\n\n## Common Anti-patterns\n\n- Copy-paste programming\n- Duplicate business logic\n- Redundant data storage\n\n## Best Practices\n\n1. Use functions and classes effectively\n2. Create reusable components\n3. Implement proper abstraction layers\n4. Utilize design patterns","src/content/principles/dry-principle.mdx","17a0fab19c4f5a4a","dry-principle.mdx","solid-principles",{"id":189,"data":191,"body":200,"filePath":201,"digest":202,"legacyId":203,"deferredRender":25},{"title":192,"description":193,"pubDate":194,"author":195,"tags":196},"SOLID Principles Explained","A deep dive into the five SOLID principles of object-oriented design",["Date","2024-01-22T00:00:00.000Z"],"Alex Johnson",[197,198,199],"SOLID","object-oriented design","best practices","# SOLID Principles Explained\n\nSOLID is an acronym for five design principles intended to make software designs more understandable, flexible, and maintainable.\n\n## Single Responsibility Principle (SRP**)**\n\nA class should have one, and only one, reason to change.\n\n## Open/Closed Principle (OCP)\n\nSoftware entities should be open for extension but closed for modification.\n\n## Liskov Substitution Principle (LSP)\n\nObjects of a superclass should be replaceable with objects of its subclasses without breaking the application.\n\n## Interface Segregation Principle (ISP)\n\nClients should not be forced to depend on interfaces they do not use.\n\n## Dependency Inversion Principle (DIP)\n\nHigh-level modules should not depend on low-level modules. Both should depend on abstractions.","src/content/principles/solid-principles.mdx","bcdf3a422c251bae","solid-principles.mdx"]