[["Map",1,2,9,10,65,66],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.5.5","content-config-digest","fb53174acf0c238e","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"ignore\",\"output\":\"static\",\"scopedStyleStrategy\":\"attribute\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":true,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":true,\"port\":4321,\"streaming\":true,\"allowedHosts\":[]},\"redirects\":{},\"image\":{\"endpoint\":{\"route\":\"/_image\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[]},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":{\"type\":\"shiki\",\"excludeLangs\":[\"math\"]},\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"github-dark\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[],\"rehypePlugins\":[],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"responsiveImages\":false,\"svg\":{\"mode\":\"sprite\"},\"serializeConfig\":false,\"headingIdCompat\":false,\"preserveScriptOrder\":false},\"legacy\":{\"collections\":false}}","principles",["Map",11,12,27,28],"solid-principles",{"id":11,"data":13,"body":22,"filePath":23,"digest":24,"legacyId":25,"deferredRender":26},{"title":14,"description":15,"pubDate":16,"author":17,"tags":18},"SOLID Principles Explained","A deep dive into the five SOLID principles of object-oriented design",["Date","2024-01-22T00:00:00.000Z"],"Alex Johnson",[19,20,21],"SOLID","object-oriented design","best practices","# SOLID Principles Explained\n\nSOLID is an acronym for five design principles intended to make software designs more understandable, flexible, and maintainable.\n\n## Single Responsibility Principle (SRP**)**\n\nA class should have one, and only one, reason to change.\n\n## Open/Closed Principle (OCP)\n\nSoftware entities should be open for extension but closed for modification.\n\n## Liskov Substitution Principle (LSP)\n\nObjects of a superclass should be replaceable with objects of its subclasses without breaking the application.\n\n## Interface Segregation Principle (ISP)\n\nClients should not be forced to depend on interfaces they do not use.\n\n## Dependency Inversion Principle (DIP)\n\nHigh-level modules should not depend on low-level modules. Both should depend on abstractions.","src/content/principles/solid-principles.mdx","bcdf3a422c251bae","solid-principles.mdx",true,"dry-principle",{"id":27,"data":29,"body":37,"filePath":38,"digest":39,"rendered":40,"legacyId":64},{"title":30,"description":31,"pubDate":32,"author":33,"tags":34},"DRY: Don't Repeat Yourself","Understanding and applying the DRY principle in software development",["Date","2024-01-23T00:00:00.000Z"],"Sarah Wilson",[9,35,36],"clean code","maintainability","# DRY: Don't Repeat Yourself\n\nThe DRY principle states that \"Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.\"\n\n## Why DRY Matters\n\n1. Reduces maintenance overhead\n2. Minimizes bugs\n3. Improves code readability\n4. Makes refactoring easier\n\n## Common Anti-patterns\n\n- Copy-paste programming\n- Duplicate business logic\n- Redundant data storage\n\n## Best Practices\n\n1. Use functions and classes effectively\n2. Create reusable components\n3. Implement proper abstraction layers\n4. Utilize design patterns","src/content/principles/dry-principle.md","17a0fab19c4f5a4a",{"html":41,"metadata":42},"\u003Ch1 id=\"dry-dont-repeat-yourself\">DRY: Don’t Repeat Yourself\u003C/h1>\n\u003Cp>The DRY principle states that “Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.”\u003C/p>\n\u003Ch2 id=\"why-dry-matters\">Why DRY Matters\u003C/h2>\n\u003Col>\n\u003Cli>Reduces maintenance overhead\u003C/li>\n\u003Cli>Minimizes bugs\u003C/li>\n\u003Cli>Improves code readability\u003C/li>\n\u003Cli>Makes refactoring easier\u003C/li>\n\u003C/ol>\n\u003Ch2 id=\"common-anti-patterns\">Common Anti-patterns\u003C/h2>\n\u003Cul>\n\u003Cli>Copy-paste programming\u003C/li>\n\u003Cli>Duplicate business logic\u003C/li>\n\u003Cli>Redundant data storage\u003C/li>\n\u003C/ul>\n\u003Ch2 id=\"best-practices\">Best Practices\u003C/h2>\n\u003Col>\n\u003Cli>Use functions and classes effectively\u003C/li>\n\u003Cli>Create reusable components\u003C/li>\n\u003Cli>Implement proper abstraction layers\u003C/li>\n\u003Cli>Utilize design patterns\u003C/li>\n\u003C/ol>",{"headings":43,"localImagePaths":58,"remoteImagePaths":59,"frontmatter":60,"imagePaths":63},[44,48,52,55],{"depth":45,"slug":46,"text":47},1,"dry-dont-repeat-yourself","DRY: Don’t Repeat Yourself",{"depth":49,"slug":50,"text":51},2,"why-dry-matters","Why DRY Matters",{"depth":49,"slug":53,"text":54},"common-anti-patterns","Common Anti-patterns",{"depth":49,"slug":56,"text":57},"best-practices","Best Practices",[],[],{"title":30,"description":31,"pubDate":61,"author":33,"tags":62},["Date","2024-01-23T00:00:00.000Z"],[9,35,36],[],"dry-principle.md","patterns",["Map",67,68,81,82],"observer-pattern",{"id":67,"data":69,"body":77,"filePath":78,"digest":79,"legacyId":80,"deferredRender":26},{"title":70,"description":71,"pubDate":72,"author":73,"tags":74},"Understanding the Observer Pattern","A comprehensive guide to implementing the Observer pattern in modern applications",["Date","2024-01-21T00:00:00.000Z"],"Jane Smith",[75,76],"design patterns","reactive programming","# Understanding the Observer Pattern\n\nThe Observer pattern defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.\n\n## Key Components\n\n1. Subject (Observable)\n2. Observer\n3. Concrete Subject\n4. Concrete Observer\n\n## Implementation Example\n\n```javascript\nclass Observable {\n    constructor() {\n        this.observers = new Set();\n    }\n\n    subscribe(observer) {\n        this.observers.add(observer);\n    }\n\n    unsubscribe(observer) {\n        this.observers.delete(observer);\n    }\n\n    notify(data) {\n        this.observers.forEach(observer => observer.update(data));\n    }\n}\n```\n\n## Real-world Applications\n\n- Event handling systems\n- User interface components\n- Real-time data updates","src/content/patterns/observer-pattern.mdx","49027a06341019c1","observer-pattern.mdx","singleton-pattern",{"id":81,"data":83,"body":91,"filePath":92,"digest":93,"legacyId":94,"deferredRender":26},{"title":84,"description":85,"pubDate":86,"author":87,"tags":88},"The Singleton Pattern in Modern JavaScript","Learn how to implement and use the Singleton pattern effectively in modern JavaScript applications",["Date","2024-01-20T00:00:00.000Z"],"John Doe",[75,89,90],"javascript","architecture","# The Singleton Pattern in Modern JavaScript\n\nThe Singleton pattern is one of the most well-known design patterns in software engineering. It ensures a class has only one instance and provides a global point of access to that instance.\n\n## Implementation in JavaScript\n\nHere's a modern implementation using ES6+ features:\n\n```javascript\nclass Singleton {\n    static #instance;\n    \n    constructor() {\n        if (Singleton.#instance) {\n            return Singleton.#instance;\n        }\n        Singleton.#instance = this;\n    }\n    \n    static getInstance() {\n        return new Singleton();\n    }\n}\n```\n\n## Use Cases\n\n1. Configuration Management\n2. Database Connections\n3. Logging Services\n\n## Best Practices\n\n- Use private fields for better encapsulation\n- Consider using dependency injection instead\n- Test for thread safety in concurrent environments","src/content/patterns/singleton-pattern.mdx","b2c6fe1526ec4380","singleton-pattern.mdx"]