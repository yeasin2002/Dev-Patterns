# SOLID Principles in Software Design

SOLID is a set of five design principles that help developers create maintainable, scalable, and robust software. These principles were introduced by **Robert C. Martin (Uncle Bob)** and are widely used in object-oriented programming.

## 1. Single Responsibility Principle (SRP)

**A class should have only one reason to change.**

- Each class should have only one responsibility or function.
- Avoids tightly coupled code and makes the system easier to maintain.

### Example:

```typescript
class ReportGenerator {
  generatePDF(): void {
    // Logic to generate a PDF report
  }
}
```

**Fix:** Separate responsibilities into different classes.

```typescript
class ReportDataFetcher {
  fetchData(): string {
    return "Report Data";
  }
}

class ReportGenerator {
  generatePDF(data: string): void {
    console.log(`Generating PDF with: ${data}`);
  }
}
```

---

## 2. Open/Closed Principle (OCP)

**Software entities should be open for extension but closed for modification.**

- New functionality should be added by extending existing code, not modifying it.
- Helps avoid breaking existing code.

### Example (Violation):

```typescript
class Rectangle {
  constructor(public width: number, public height: number) {}
}

class AreaCalculator {
  calculate(rectangle: Rectangle): number {
    return rectangle.width * rectangle.height;
  }
}
```

**Fix:** Use polymorphism to extend functionality.

```typescript
interface Shape {
  getArea(): number;
}

class Rectangle implements Shape {
  constructor(public width: number, public height: number) {}
  getArea(): number {
    return this.width * this.height;
  }
}

class Circle implements Shape {
  constructor(public radius: number) {}
  getArea(): number {
    return Math.PI * this.radius * this.radius;
  }
}
```

---

## 3. Liskov Substitution Principle (LSP)

**Derived classes must be substitutable for their base classes.**

- A subclass should not break the functionality of a parent class.
- Prevents unexpected behaviors in the system.

### Example (Violation):

```typescript
class Bird {
  fly(): void {
    console.log("Flying");
  }
}

class Penguin extends Bird {
  fly(): void {
    throw new Error("Penguins can't fly!");
  }
}
```

**Fix:** Use composition instead of inheritance.

```typescript
interface CanFly {
  fly(): void;
}

class Bird {}

class Sparrow extends Bird implements CanFly {
  fly(): void {
    console.log("Flying");
  }
}

class Penguin extends Bird {
  swim(): void {
    console.log("Swimming");
  }
}
```

---

## 4. Interface Segregation Principle (ISP)

**Clients should not be forced to depend on interfaces they do not use.**

- Avoid bloated interfaces with methods that some classes don't need.
- Break large interfaces into smaller, more specific ones.

### Example (Violation):

```typescript
interface Worker {
  work(): void;
  eat(): void;
}

class Robot implements Worker {
  work(): void {
    console.log("Working");
  }
  eat(): void {
    throw new Error("Robots donâ€™t eat");
  }
}
```

**Fix:** Split interfaces into smaller ones.

```typescript
interface Workable {
  work(): void;
}

interface Eatable {
  eat(): void;
}

class Human implements Workable, Eatable {
  work(): void {
    console.log("Working");
  }
  eat(): void {
    console.log("Eating");
  }
}

class Robot implements Workable {
  work(): void {
    console.log("Working");
  }
}
```

---

## 5. Dependency Inversion Principle (DIP)

**High-level modules should not depend on low-level modules. Both should depend on abstractions.**

- Use interfaces to decouple dependencies.
- Promotes flexibility and makes testing easier.

### Example (Violation):

```typescript
class MySQLDatabase {
  connect(): void {
    console.log("Connected to MySQL");
  }
}

class DataService {
  database: MySQLDatabase = new MySQLDatabase();
  fetchData(): void {
    this.database.connect();
  }
}
```

**Fix:** Use dependency injection.

```typescript
interface Database {
  connect(): void;
}

class MySQLDatabase implements Database {
  connect(): void {
    console.log("Connected to MySQL");
  }
}

class DataService {
  constructor(private database: Database) {}
  fetchData(): void {
    this.database.connect();
  }
}

const db = new MySQLDatabase();
const service = new DataService(db);
service.fetchData();
```

---

## Conclusion

By following **SOLID principles**, you can:
âœ… Improve code maintainability and readability.
âœ… Reduce dependencies and avoid tight coupling.
âœ… Make it easier to extend functionality without modifying existing code.

Using these principles ensures that your software remains scalable and easier to manage in the long run. ðŸš€
